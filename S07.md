# S07

En S07 on a remis notre casquette de développeur front.

On utilise des langages interprétés dans le navigateur, HTML pour le fond, CSS pour la forme et JS pour les intéractions.

Grâce à JS dans le navigateur on peut réagir aux intéractions de l'utilisateur pour faire évoluer le DOM.

Notre boulôt en tant que dev back était de préparer les données. En fonction d'une demande, on traite la donnée et on construit une réponse.
En tant que dev front notre boulot est de construire l'interface utilisateur, le moyen facilitant la consultation et l'intéraction avec nos données.

Avant la s6 l'utilisateur pouvait soumettre des formulaire ou cliquer sur des liens qui généraient de nouvelles requetes HTTP, le serveur renvoyait une réponse adapté en HTML.

En S6/7 on travaille en mode API. Le back sait gérer des opérations sur la BDD et nous expose des endpoints pour demander ces opérations. Il nous répond du JSON.

En front, on génère plus de requete HTTP par défaut en réponse aux intéractions. On fait des SPA (single page application). Une age qu'on n'actualise pas. On décrira en javascript comment faire évoluer le DOM en réponse à des intéractions. Si on a besoin de faire persister ou de récupérer des choses de la BDD, on contactera l'api qui sait nous répondre via des reuetes HTTP émises depuis nos scripts JS en ajax. On utilisera la réponse json dans nos scripts comme source d'info pour alimenter notre interface.

## Nos objectifs principaux en front

- Cibler un élement / traverser le DOM
  - `document.querySelector('.selector')`
  - `document.querySelectorAll('.selector')`
  - `element.previousElementSibling`
  - `element.nextElementSibling`
  - `element.closest('.selector')`
- Créer des élements
  - `document.createElement('div')`
  - `template.content.cloneNode(true)`
- Modifier des élements
  - `element.textContent`
  - `element.classList`
  - `element.style`
  - `element.setAttribute('nom', 'valeur')`
- Insérer des élements
  - `parent.appendChild(enfant);`
  - `voisin.before(nouveauVoisin);`
  - `voisin.after(nouveauVoisin);`
- Réagir à un événement
  - `element.addEventListener('click', funtion() {});`
  - `element.addEventListener('submit', funtion() {});`
  - `element.addEventListener('dblclick', funtion() {});`
- Récupérer les valeur d'un fomulaire
  - `inputElement.value`
  - `new FormData(formElement);`
- Utiliser le DOM pour écrire une donnée
  - les attributs custom data-*suffix* ou _dataset_
```js
// on prefixe nos attributs custom avec data-
// Ainsi ils seront automatiquement repris dans la propriété dataset de l'element dans un objet avec chaque propriété en camelCase
// <input data-test="toto" data-list-id="4"
document.querySelector('input').dataset; 
/* nous donne
{
  test: "toto",
  listId: "4",
}
*/
```
- Faire des requêtes HTTP en ajax
  - `fetch()`

## Exemples de fetch

### Par défaut, du get

```js
fetch('http://monapi.com/faitqqch');
```

### Possible de spécifier la méthode (POST, PATCH, PUT, ...)

On passe en 2nd argument un objet spécifiant la méthode et le corps de la requete

```js
fetch('http://monapi.com/faitqqch', {
  method: 'POST',
  body: data
});
```

### Utilisation de la valeur de retour

On travaille dans une fonction asynchrone pour pouvoir attendre le retour de nos promesses

```js
const fetchSomething = async function() {
  const response = await fetch('http://monapi.com/faitqqch');
  const body = await response.json();
  if (response.status === 200) {
      console.log(body);
  }
  else {
      console.error('Il y a eu un problème');
  }
}
```

### Gestion des erreurs avec try/catch

S'il y a eu un soucis l'api ne renverra peut etre pas nos données mais un message d'erreur. On peut alors jeter une erreur pour réagir de manière adapter

```js
const fetchSomething = async function() {
  try {
    const response = await fetch('http://monapi.com/faitqqch');
    const body = await response.json();
    if (response.status === 200) {
      console.log(body);
    }
    else {
      throw new Error(body);
    }
  } catch(error) {
    alert('Il y a eu un soucis');
    console.error(error);
  }
}
```

---

## Bundler

Les bundler sont des outils qui permettent de

- gérer nos fichiers sous forme de module (on devra exporter et importer explicitement ce dont on a besoin) chaque fichier est autonome
- rassembler nos fichiers en 1 seul ou plusieurs gros paquets
- d'appliquer des traitements pour optimiser nos fichiers

Il en existe plusieurs : https://www.npmtrends.com/browserify-vs-webpack-vs-grunt-vs-gulp-vs-parcel

Aujourd'hui on découvre browserify

### Utilisations

On l'installe

On a initialisé un projet avec npm `npm init -y`

On a installé browserify `npm install browserify --save-dev`

On a préparé le script pour lancé le travail de browserify `"build": "browserify src/app.js -o assets/js/bundle.js"`

On lance un script avec `npm run nomDuScript`

On distingue désormais le code qu'on écrit / le code de développement / le code nécessaire au travail de browserify. On le range généralement dans un dossier nommé `src`

Browserify va explorer un point d'entrée présent dans src et suivre les imports pour générer le code final de production, ce qu'on a appelé bundle.js, c'est le code qui sera utilisé par le navigateur

On va ainsi répondre aux critères de qualité de chacun :

- On écrit du code bien rangé, bien organisé, bien découpé, bien commenté, lisible, pour les développeurs dans src
- Puis on rassemble grace à browserify tout ça un fichier optimisé pour etre rapide à chargé dans le navigateur

Le minimum syndical pour un bundler c'est de savoir rassembler des fichiers en 1. Avec browserify on utilise `module.exports` pour rendre disponible ailleurs un partie d'un fichier. On l'importa là où on en a besoin avec `require('./chemin/vers/module')`

On peut aller plus loin en se servant du bundler pour déclencher le travail d'autres outils. Par exemple aujourd'hui on test https://www.npmjs.com/package/tinyify
Tinyify va prendre notre code et retirer tous les espaces inutiles, tous les commentaires, les sauts de lignes, ... pour rendre le code final plus léger et donc plus rapide à charger dans le navigateur (ex aujourd'hui on est passé de 15ko à 5ko, on a divisé par 3 le poids du code)

En plus on peut généralement configurer nos bundler pour rendre notre environnement de développement idéal. On a pu ajouter le plugin `watchify` pour relancer automatiquement le travail de browserify à chaque modif. On a pu utiliser l'option `--debug` pour avoir les bons numéros de ligne quand on debug ou quand on a des messages d'erreurs. Attention tout de meme à penser à ne pas utiliser l'option debug pour la génération final du bundle de production